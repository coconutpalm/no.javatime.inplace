/*******************************************************************************
 * Copyright (c) 2011, 2012 JavaTime project and others
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 * 	JavaTime project, Eirik Gronsund - initial implementation
 *******************************************************************************/
package no.javatime.inplace.region.state;

import no.javatime.inplace.region.Activator;
import no.javatime.inplace.region.events.TransitionEvent;
import no.javatime.inplace.region.manager.BundleCommandImpl;
import no.javatime.inplace.region.manager.BundleManager;
import no.javatime.inplace.region.manager.BundleTransition.Transition;
import no.javatime.inplace.region.manager.BundleTransition.TransitionError;
import no.javatime.inplace.region.manager.BundleTransitionImpl;
import no.javatime.inplace.region.manager.BundleWorkspaceRegionImpl;
import no.javatime.inplace.region.manager.ProjectLocationException;
import no.javatime.inplace.region.msg.Msg;
import no.javatime.inplace.region.project.BundleProjectState;
import no.javatime.inplace.region.project.ManifestOptions;
import no.javatime.inplace.region.status.BundleStatus;
import no.javatime.inplace.region.status.IBundleStatus.StatusCode;
import no.javatime.util.messages.Category;
import no.javatime.util.messages.ExceptionMessage;
import no.javatime.util.messages.TraceMessage;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.runtime.Status;
import org.eclipse.osgi.util.NLS;
import org.eclipse.ui.statushandlers.StatusManager;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleEvent;
import org.osgi.framework.SynchronousBundleListener;

/**
 * Bundle listener acting on events received from the OSGI framework.
 * Framework and bundle events are initiated by bundle operations in
 * {@link BundleCommandImpl} or from an external source(e.g. the OSGi Framework or the OSGi Bundle Console)
 * <p>
 * Events not generated by operations from {@link BundleCommandImpl} are marked as external
 * transitions and flagged as such if the user information option is switched on. An internal bundle
 * state is maintained according to a deterministic finite machine.
 * <p>
 * If a bundle is uninstalled from an external source in an activated workspace the workspace is automatically
 * deactivated if automatic handling of external commands is switched on. If off, the user has the option to
 * deactivate the workspace or install, resolve and possibly start the uninstalled bundle again.
 * <p>
 * The design supports a concept of a region bounded bundle structure ({@link BundleWorkspaceRegionImpl}) acted on
 * by bundle operations ({@link BundleCommandImpl}), which in turn creates a result (events) to interpret and
 * react upon ({@code BundleStateEvents}). This interrelationship is not interpreted as a sequence or a flow,
 * although present, but as a structural coherence.
 * <p>
 */
public class BundleStateEvents implements SynchronousBundleListener {

	private final BundleWorkspaceRegionImpl bundleRegion = BundleWorkspaceRegionImpl.INSTANCE;
	private final BundleCommandImpl bundleCommand = BundleCommandImpl.INSTANCE;
	private final BundleTransitionImpl bundleTransition = BundleTransitionImpl.INSTANCE;

	/**
	 * Default empty constructor.
	 */
	public BundleStateEvents() {
	}

	/**
	 * Identify and adjust bundle state for external bundle operations, bundle operations spanning multiple
	 * transitions and "on demand" class loading of lazy activated bundles.The current state of a bundle, which
	 * changes after an internal (or external) workspace bundle operation is executed, is adjusted and recorded
	 * along with the bundle in a bundle node. If received bundle events from the framework deviates from the
	 * current recorded state of the bundle the transition (operation) who initiated the events is treated as an
	 * external operation and actions are taken to update the bundle node with the new state caused by the
	 * external transition.
	 * <p>
	 * An exception is when a bundle with lazy activation policy is started due to "on demand" class loading.
	 * This is a transition generated by the framework, and the maintained state of the bundle is adjusted after
	 * the fact from a lazy activation state to an active state.
	 * <p>
	 * It is allowed to execute external commands both in an activated and a deactivated workspace except for
	 * uninstalling workspace bundles or resolving or starting deactivated bundles in an activated workspace.
	 * Uninstalling workspace bundles in an activated workspace from an external source is acted upon and bundle
	 * operations are executed - either automatically or based on user choice - to maintain the workspace
	 * consistent with the definition of an activated workspace. In the second case, resolving or starting a
	 * deactivated bundle from an external source in an activated workspace, is rejected by the resolver hook.
	 */
	@Override
	public void bundleChanged(BundleEvent event) {
		
		final Bundle bundle = event.getBundle();
		// Consider all workspace bundle projects 
		final IProject project = bundleRegion.getBundleProject(bundle);
		if (null == project) {
			return; // jar bundle
		}
		BundleNode bundleNode = bundleRegion.getBundleNode(project);
		// Project is not registered yet. External command or a new (import, open create) project in a deactivated workspace
		if (null == bundleNode) {
			bundleNode = bundleCommand.registerBundleNode(project, bundle, BundleProjectState.isNatureEnabled(project));					
		}
		// Get OSGi bundle state and the registered bundle project (bundle node)
		final int eventType = event.getType();
		// The project is registered as a bundle project and will not be null
		BundleState state = bundleNode.getState(); 
		Transition transition = bundleNode.getTransition(); 
		
		// Examine all bundle events sent by the framework and update bundle state when external bundle
		// operations are executed, when lazy activated bundles are loaded on demand by the framework and
		// BundleJobManager commands (transitions) spans multiple states
		switch (eventType) {
		// @formatter:off 
		/*
		 * Incoming transitions with Installed as the current state: 
		 * Previous state: Uninstalled. Possible transitions: Install 
		 * Previous state: Installed. Possible transitions: Update, Refresh
		 * Comments: 
		 * Updating an installed bundle is relevant when activating a bundle in an activated workspace.
		 * Refresh on an installed bundle is not put to use
		 */
		case BundleEvent.INSTALLED: {
			// The bundle is now installed and it is possible to register the bundle along with its registered project
			// If the bundle project has a valid transition it is installed by this plug in
			if (Transition.INSTALL == transition && null == bundleNode.getBundleId()) {
				bundleNode = bundleCommand.registerBundleNode(project, bundle, BundleProjectState.isNatureEnabled(project));		
			} else {
				// The bundle project should be in state installed if installed by this plug in. If not treat it as an external install
				if (null == state || !(state instanceof InstalledState)) {
					// Register the external installed workspace bundle
					bundleNode = bundleCommand.registerBundleNode(project, bundle, BundleProjectState.isNatureEnabled(project));
					bundleNode.getState().install(bundleNode);
					bundleNode.setTransition(Transition.EXTERNAL);
					// Inform about external transition message
					final String originName = bundleRegion.getSymbolicKey(event.getOrigin(), null);
					final String symbolicName = bundleRegion.getSymbolicKey(bundle, null);
					final String stateName = bundleCommand.getStateName(event);
					final String bundleLocation = bundle.getLocation();
					String msg = NLS.bind(Msg.EXT_BUNDLE_OP_ORIGIN_INFO, new Object[] {symbolicName, stateName,
							originName, bundleLocation});
					StatusManager.getManager().handle(new BundleStatus(StatusCode.INFO, Activator.PLUGIN_ID, msg), StatusManager.LOG);
				}
			}
			break;
		}
		
		/*
		 * Previous state: Resolved. Possible transitions: Refresh, Update, Uninstall 
		 * Comments: 
		 * Refresh unresolves and resolves a bundle. If the bundle is already deactivated it is rejected by the 
		 * resolver hook and not resolved again. 
		 * A bundle to update is unresolved before the installed bundle is updated.
		 */
		case BundleEvent.UNRESOLVED: {
			if ((state instanceof InstalledState)) {
				// The bundle was uninstalled from state resolved. 
				// Multiple states: Resolved-Installed-Uninstalled
				if (Transition.UNINSTALL == transition) {
					state.uninstall(bundleNode);
					// The bundle was refreshed from state resolved
					// Multiple states: Resolved-Installed-Resolved)
				} else if (Transition.REFRESH == transition) {
					state.refresh(bundleNode);
				}
			} else {
				bundleNode.setCurrentState(StateFactory.INSTANCE.installedState);
				externalTransitions(event);
			}
			break;
		}
		/*
		 * Incoming transitions with Installed as the current state: 
		 * Previous state: Installed. Possible transitions: Update 
		 * Comments: 
		 * Update does not alter the state of the installed bundle.
		 */
		case BundleEvent.UPDATED: {
			if (!(state instanceof InstalledState)) {
				bundleNode.setCurrentState(StateFactory.INSTANCE.installedState);
				externalTransitions(event);
			}
			break;
		}
		/*
		 * Incoming transitions with Uninstalled as the current state: 
		 * Previous state: Installed. Possible transitions: Uninstall
		 */
		case BundleEvent.UNINSTALLED: {
			if (!(state instanceof UninstalledState)) {
				if (null != bundleNode) {
					bundleNode.setCurrentState(StateFactory.INSTANCE.uninstalledState);
				}
				// Uninstalling a bundle from an external source is not permitted in an activated workspace
				if (BundleProjectState.isWorkspaceNatureEnabled()) {
					bundleTransition.setTransitionError(bundle, TransitionError.UNINSTALL);
				} else {
					// Remove the externally uninstalled bundle from the workspace region
					bundleCommand.unregisterBundle(bundle);
				}
				externalTransitions(event);
			}
			break;
		}

		/*
		 * When a lazy bundle is resolved it is moved to starting state
		 */
		case BundleEvent.LAZY_ACTIVATION: {
			if (!(state instanceof LazyState)) {
				bundleNode.setCurrentState(StateFactory.INSTANCE.lazyState);
				externalTransitions(event);
			}
			break;
		}

		/*
		 * Framework publish this event before calling BundleActivator.start
		 * <p>
		 * Activates a bundle with eager activation policy. Lazy bundles are activated
		 * implicit by the framework due to "on demand" class loading. To get a consistent
		 * state machine a new transition and state is generated for lazy loaded bundles.
		 */
		case BundleEvent.STARTING: {
			if (state instanceof LazyState) {
				// Generate a transition on behalf of the framework.
				// The internal state is now resolved (not starting) and the transition is refresh
				// The start transition when in state resolved is the same as
				bundleNode.begin(Transition.LAZY_LOAD, StateFactory.INSTANCE.lazyState);
				//state.start(bundleNode);
				BundleManager.addBundleTransition(new TransitionEvent(bundle, bundleNode.getTransition())); 
			} else if (!(state instanceof ActiveState)) {
				bundleNode.setCurrentState(StateFactory.INSTANCE.activeState);
				externalTransitions(event);
			}
			break;
		}
		/*
		 * Framework publish this event after calling BundleActivator.start
		 * <p>
		 * Incoming transitions with Active as the current state: 
		 * Previous state: Starting. Possible transitions: Start
		 */
		case BundleEvent.STARTED: {
			// Move from lazy to activated (see the starting event) for lazy bundles
			if (state instanceof LazyState && bundleNode.isStateChanging()) {
				bundleNode.commit(Transition.START, StateFactory.INSTANCE.activeState);
				state = bundleNode.getState();
				state.commit(bundleNode);
				BundleManager.addBundleTransition(new TransitionEvent(bundle, bundleNode.getTransition())); 
			}
			if (!(state instanceof ActiveState)) {
				bundleNode.setCurrentState(StateFactory.INSTANCE.activeState);
				externalTransitions(event);
			}
			break;
		}
		/*
		 * Framework publish this event before calling BundleActivator.stop
		 * <p>
		 * Incoming transitions with Stopping as the current state: 
		 * Previous state: Active. Possible transitions: Stop
		 */
		case BundleEvent.STOPPING:
			break;

		/*
		 * The Framework publish this event after calling BundleActivator.stop or when a runtime
		 * error occurs during start (incomplete transition)
		 * <p>
		 * If the BundleActivator.start method throws an exception the framework publish a
		 * STOPPED event but the internal transition was START (not STOP). This could also
		 * be an external command stopping the bundle or starting the bundle throwing an exception
		 * <p>
		 * For eager activated bundles when a stopped event is published and the initial start
		 * command was invoked internally just leave it. A roll back is issued by the start routine
		 * which invoked the start command. For lazy loaded bundles roll back the 
		 * start command generated in the starting event.
		 */
		case BundleEvent.STOPPED: {
			// An external command or an exception thrown in the start method
			if (transition == Transition.START || transition == Transition.LAZY_LOAD) {
				if (bundleNode.isStateChanging()) {
					if (transition == Transition.LAZY_LOAD) {					
						// Previous state is resolved and current state is lazy load
						//state.rollBack(bundleNode);
						//state = bundleNode.getState();
						bundleNode.commit(Transition.RESOLVE, StateFactory.INSTANCE.resolvedState);
						state = bundleNode.getState();
					}
				}
			} else if (!(state instanceof ResolvedState)) {
				// Assume an external command
				bundleNode.commit(Transition.STOP, StateFactory.INSTANCE.resolvedState);		
				// bundleNode.setCurrentState(StateFactory.INSTANCE.resolvedState);
				externalTransitions(event);
			}
			break;
		}
		/*
		 * Incoming transitions with Resolved as the current state: 
		 * Previous state: Resolved. Possible transitions: Refresh 
		 * Previous state: Installed. Possible transitions: Resolve 
		 * Comments: 
		 * Resolving (and refreshing) bundles with lazy activation policy are moved to state 
		 * Starting by the framework
		 */
		case BundleEvent.RESOLVED: {
			// Refresh or resolve
			if (!(state instanceof ResolvedState) && !(state instanceof LazyState)) {
				if (ManifestOptions.getlazyActivationPolicy(bundle)) {
					bundleNode.commit(transition, StateFactory.INSTANCE.lazyState);
				} else {
					bundleNode.commit(transition, StateFactory.INSTANCE.resolvedState);
				}
				externalTransitions(event);
			}
//			if (state instanceof ResolvedState) {
//				if (Transition.RESOLVE == transition) {
//					if (ManifestOptions.getlazyActivationPolicy(bundle)) {
//						bundleNode.setCurrentState(StateFactory.INSTANCE.lazyState);
//					}
//				} else if (Transition.REFRESH == transition) {
//					if (ManifestOptions.getlazyActivationPolicy(bundle)) {
//						bundleNode.setCurrentState(StateFactory.INSTANCE.lazyState);
//					}
//				}
//			} else {
//				if (ManifestOptions.getlazyActivationPolicy(bundle)) {
//					bundleNode.setCurrentState(StateFactory.INSTANCE.lazyState);
//				} else {
//					bundleNode.setCurrentState(StateFactory.INSTANCE.resolvedState);
//				}
//				undefinedTransitions(event);
//			}
			break;
		}
		default: {
			externalTransitions(event);
		}
		} // switch
		// @formatter:on
		// Event trace
		if (Category.getState(Category.bundleEvents)) {
			try {
				TraceMessage.getInstance().getString("bundle_event", bundle, bundleCommand.getStateName(event),
						bundleCommand.getStateName(bundle), bundleTransition.getTransitionName(project));
			} catch (ProjectLocationException e) {
				String msg = ExceptionMessage.getInstance().formatString("project_location_error", project.getName());
				StatusManager.getManager().handle(new Status(Status.ERROR, Activator.PLUGIN_ID, 
						msg), StatusManager.LOG);

			}
		}
	}

	/**
	 * Register external and incomplete transitions and informs that they have been executed.
	 * 
	 * @param event bundle event after a bundle operation has been executed
	 */
	private void externalTransitions(BundleEvent event) {
		Bundle bundle = event.getBundle();
		final String location = bundle.getLocation();
		BundleCommandImpl bundleCommand = BundleCommandImpl.INSTANCE;
		BundleTransitionImpl bundleTransition = BundleTransitionImpl.INSTANCE;
		final String symbolicName = bundleRegion.getSymbolicKey(bundle, null);
		final String stateName = bundleCommand.getStateName(event);
		if (bundleTransition.getError(bundle) == TransitionError.INCOMPLETE) {
			String msg = NLS.bind(Msg.INCOMPLETE_BUNDLE_OP_INFO, new Object[] {symbolicName, stateName,
					location});
			StatusManager.getManager().handle(new BundleStatus(StatusCode.INFO, Activator.PLUGIN_ID, msg), StatusManager.LOG);				
		} else {
			TransitionError error = bundleTransition.getError(bundle);
			bundleTransition.setTransition(bundle, Transition.EXTERNAL);
			bundleTransition.setTransitionError(bundle, error);
			BundleManager.addBundleTransition(new TransitionEvent(bundle, Transition.EXTERNAL));
			String msg = NLS.bind(Msg.EXT_BUNDLE_OP_INFO, new Object[] {symbolicName, stateName,
					location});
			StatusManager.getManager().handle(new BundleStatus(StatusCode.INFO, Activator.PLUGIN_ID, msg), StatusManager.LOG);
		}
	}
}